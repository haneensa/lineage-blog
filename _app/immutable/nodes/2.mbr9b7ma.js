import{f as C,a as k}from"../chunks/Kp7sLg-y.js";import"../chunks/CpO_WCtV.js";import{A as xe,F as mt,K as Ae,j as X,a1 as _t,v as bt,g as a,U as wt,H as yt,I as Tt,J as Ve,M as Se,C as ge,ad as Et,aH as xt,ap as Ye,w as At,aP as K,B as Ce,aQ as St,E as It,a9 as ze,aL as ae,aF as He,aR as Nt,aS as kt,aT as Ct,aU as Rt,x as Ke,z as Ze,aV as Ie,aB as Ht,aW as Ot,aE as Lt,y as $t,aq as _e,p as et,s as l,o as tt,h as o,q as at,i as e,t as M,b as te,R as z}from"../chunks/DxiQdkCR.js";import{s as T,e as J}from"../chunks/DQRcQ8WQ.js";import{p as Ne,i as U}from"../chunks/CXLViFzr.js";import{s as fe}from"../chunks/DvSqlD5E.js";import{i as rt}from"../chunks/CZ1LnZdr.js";import{b as me}from"../chunks/BM43ke9o.js";function ue(r,h){return h}function Ft(r,h,n){for(var c=[],f=h.length,v,u=h.length,i=0;i<f;i++){let b=h[i];Ze(b,()=>{if(v){if(v.pending.delete(b),v.done.add(b),v.pending.size===0){var x=r.outrogroups;Re(He(v.done)),x.delete(v),x.size===0&&(r.outrogroups=null)}}else u-=1},!1)}if(u===0){var m=c.length===0&&n!==null;if(m){var p=n,_=p.parentNode;Lt(_),_.append(p),r.items.clear()}Re(h,!m)}else v={pending:new Set(h),done:new Set},(r.outrogroups??=new Set).add(v)}function Re(r,h=!0){for(var n=0;n<r.length;n++)$t(r[n],h)}var Je;function ce(r,h,n,c,f,v=null){var u=r,i=new Map;{var m=r;u=X?Ae(_t(m)):m.appendChild(xe())}X&&bt();var p=null,_=wt(()=>{var A=n();return Nt(A)?A:A==null?[]:He(A)}),b,x=!0;function W(){H.fallback=p,qt(H,b,u,h,c),p!==null&&(b.length===0?(p.f&K)===0?Ke(p):(p.f^=K,de(p,null,u)):Ze(p,()=>{p=null}))}var s=mt(()=>{b=a(_);var A=b.length;let w=!1;if(X){var g=yt(u)===Tt;g!==(A===0)&&(u=Ve(),Ae(u),Se(!1),w=!0)}for(var E=new Set,S=At,I=It(),N=0;N<A;N+=1){X&&ge.nodeType===Et&&ge.data===xt&&(u=ge,w=!0,Se(!1));var P=b[N],O=c(P,N),$=x?null:i.get(O);$?($.v&&Ye($.v,P),$.i&&Ye($.i,N),I&&S.unskip_effect($.e)):($=Ut(i,x?u:Je??=xe(),P,O,N,f,h,n),x||($.e.f|=K),i.set(O,$)),E.add(O)}if(A===0&&v&&!p&&(x?p=Ce(()=>v(u)):(p=Ce(()=>v(Je??=xe())),p.f|=K)),A>E.size&&St(),X&&A>0&&Ae(Ve()),!x)if(I){for(const[pe,re]of i)E.has(pe)||S.skip_effect(re.e);S.oncommit(W),S.ondiscard(()=>{})}else W();w&&Se(!0),a(_)}),H={effect:s,items:i,outrogroups:null,fallback:p};x=!1,X&&(u=ge)}function le(r){for(;r!==null&&(r.f&Ot)===0;)r=r.next;return r}function qt(r,h,n,c,f){var v=h.length,u=r.items,i=le(r.effect.first),m,p=null,_=[],b=[],x,W,s,H;for(H=0;H<v;H+=1){if(x=h[H],W=f(x,H),s=u.get(W).e,r.outrogroups!==null)for(const O of r.outrogroups)O.pending.delete(s),O.done.delete(s);if((s.f&K)!==0)if(s.f^=K,s===i)de(s,null,n);else{var A=p?p.next:i;s===r.effect.last&&(r.effect.last=s.prev),s.prev&&(s.prev.next=s.next),s.next&&(s.next.prev=s.prev),Y(r,p,s),Y(r,s,A),de(s,A,n),p=s,_=[],b=[],i=le(p.next);continue}if((s.f&Ie)!==0&&Ke(s),s!==i){if(m!==void 0&&m.has(s)){if(_.length<b.length){var w=b[0],g;p=w.prev;var E=_[0],S=_[_.length-1];for(g=0;g<_.length;g+=1)de(_[g],w,n);for(g=0;g<b.length;g+=1)m.delete(b[g]);Y(r,E.prev,S.next),Y(r,p,E),Y(r,S,w),i=w,p=S,H-=1,_=[],b=[]}else m.delete(s),de(s,i,n),Y(r,s.prev,s.next),Y(r,s,p===null?r.effect.first:p.next),Y(r,p,s),p=s;continue}for(_=[],b=[];i!==null&&i!==s;)(m??=new Set).add(i),b.push(i),i=le(i.next);if(i===null)continue}(s.f&K)===0&&_.push(s),p=s,i=le(s.next)}if(r.outrogroups!==null){for(const O of r.outrogroups)O.pending.size===0&&(Re(He(O.done)),r.outrogroups?.delete(O));r.outrogroups.size===0&&(r.outrogroups=null)}if(i!==null||m!==void 0){var I=[];if(m!==void 0)for(s of m)(s.f&Ie)===0&&I.push(s);for(;i!==null;)(i.f&Ie)===0&&i!==r.fallback&&I.push(i),i=le(i.next);var N=I.length;if(N>0){var P=v===0?n:null;Ft(r,I,P)}}}function Ut(r,h,n,c,f,v,u,i){var m=(u&kt)!==0?(u&Ct)===0?ae(n,!1,!1):ze(n):null,p=(u&Rt)!==0?ze(f):null;return{v:m,i:p,e:Ce(()=>(v(h,m??n,p??f,i),()=>{r.delete(c)}))}}function de(r,h,n){if(r.nodes)for(var c=r.nodes.start,f=r.nodes.end,v=h&&(h.f&K)===0?h.nodes.start:n;c!==null;){var u=Ht(c);if(v.before(c),c===f)return;c=u}}function Y(r,h,n){h===null?r.effect.first=n:h.next=n,n===null?r.effect.last=h:n.prev=h}const Xe=[...` 	
\r\f \v\uFEFF`];function Mt(r,h,n){var c=""+r;if(n){for(var f in n)if(n[f])c=c?c+" "+f:f;else if(c.length)for(var v=f.length,u=0;(u=c.indexOf(f,u))>=0;){var i=u+v;(u===0||Xe.includes(c[u-1]))&&(i===c.length||Xe.includes(c[i]))?c=(u===0?"":c.substring(0,u))+c.substring(i+1):u=i}}return c===""?null:c}function ke(r,h,n,c,f,v){var u=r.__className;if(X||u!==n||u===void 0){var i=Mt(n,c,v);(!X||i!==r.getAttribute("class"))&&(i==null?r.removeAttribute("class"):r.className=i),r.__className=n}else if(v&&f!==v)for(var m in v){var p=!!v[m];(f==null||p!==!!f[m])&&r.classList.toggle(m,p)}return v}var Wt=C(`<h2>Lineage Graph = Provenance Polynomials</h2> <p>Another way to reason about the lineage graph is mathematically, using provenance polynomials.
In this abstraction, each input tuple is assigned a variable (e.g., <code>c1</code> for the first customer, <code>o1</code> for the first order), 
and relational operations combine these variables to represent how outputs are constructed:</p> <ul><li><strong>Join:</strong> multiply the variables of joined tuples</li> <li><strong>Union, projection, aggregation:</strong> add the variables of contributing tuples</li></ul> <p>For example, suppose customer <code>c1</code> is joined to orders <code>o1</code> and <code>o2</code> then its aggregated. 
The total spend for this customer can be represented as the polynomial: <code>c1*o1 + c1*o2</code></p> <p>This algebraic representation provides a compact, flexible summary of the same lineage graph.
For example, the lineage for each output row of Q1 can be written directly as a polynomial over input tuples:</p> <p>Each term shows a combination of customer and order rows that contributed to the output.</p> <p>These polynomials let us reason about the workflow without recomputing the full lineage.
By assigning different values to the variables and how we interpret the binary operators <code>(+,x)</code>,
we can perform a wide range of practical analyses, such as:</p> <ul><li><strong>Aggregates:</strong> count(), sum(), or average() over any subset of inputs</li> <li><strong>Confidentiality scoring:</strong> propagate sensitivity levels from inputs to outputs</li> <li><strong>Probabilistic reasoning:</strong> evaluate uncertainty over inputs</li> <li>View maintenance: quickly determine which outputs to keep or delete</li> <li><strong>“What-if” scenarios:</strong> simulate deletions, updates, or modifications of input rows</li></ul>`,1);function Pt(r){var h=Wt();_e(14),k(r,h)}var Bt=C("<tr><td> </td><td> </td><td> </td></tr>"),Dt=C("<li><strong> </strong> <code> </code></li>"),jt=C(`<h2>How to model lineage in the Relational Model?</h2> <p>While provenance polynomials give a compact mathematical view of lineage, we also need a way to represent and query this information in practice,
using the tools data engineers and analysts already have.</p> <p>In relational databases, we can encode the lineage graph by tracking, for each output row, which input tuples contributed to it.
The basic approach is:</p> <ul><li>Assign a unique <strong>row ID</strong> to each input tuple (for example, using the tuple's position in <code>customer</code> and <code>orders</code> tables).</li> <li>For each output row, store the <strong>list of contributing input row IDs</strong>.</li> <li>Optionally use <code>UNNEST</code> operations to generate a <strong>lineage_edges</strong> table of edges connecting inputs to outputs.</li></ul> <p>For our Q1 example, this can be expressed in SQL as:</p> <pre><code class="language-sql"></code></pre> <table class="table table-bordered table-sm"><thead><tr><th>rowid</th><th>customer_iid</th><th>orders_iid</th></tr></thead><tbody></tbody></table> <p>This <strong>lineage_edges</strong> represents the same information captured by the provenance polynomials,
but in a concrete relational format: each row corresponds to an <strong>edge in the lineage graph</strong>, connecting an input tuple to an output tuple.</p> <h4>Reconstructing Provenance Polynomial</h4> <p>Once we have the lineage edges connecting input tuples to outputs, we can reconstruct the provenance polynomial for each output directly in SQL. Each term in the polynomial corresponds to a pair of input tuples — for example, a customer and an order — that contributed to the output.</p> <pre><code class="language-sql"></code></pre> <p>Each row in the <code>lineage_edges</code> table connects an input customer (<code>customer_iid</code>) to an input order (<code>orders_iid</code>) for a specific output row (<code>oid</code>). We can reconstruct the provenance polynomial for each output by combining these edges: each term <code>cX*oY</code> represents a <strong>join of a customer and an order</strong> that contributed to the output. Using <code>STRING_AGG(..., ' + ')</code>, we sum all contributing terms, reflecting the <strong>addition in provenance polynomials</strong>.</p> <p>For our Q1 example, we also include orders.value, this produces:</p> <ul></ul> <p>This provides a <strong>concrete, queryable representation</strong> of the abstract polynomial, bridging theory and practice while keeping it fully relational.</p> <h4>Use Case 1: Evaluating Confidentialiy</h4> <p>We can also use the lineage edges to propagate metadata from inputs to outputs.
For example, consider sensitivity levels (unclassified &rarr; sensitive &rarr; top_secret) on each order. Using the lineage, we can compute the final sensitivity of each output row based on the most sensitive contributing order:</p> <pre><code class="language-sql"></code></pre> <p>This aggregates the sensitivities of all orders contributing to each output.
The MAX ensures that the output row is labeled with the most sensitive input.
This is a practical example of how provenance can be used for data governance, compliance, and risk assessment.</p> <h4>Use Case 2: What-if Analysis (Hypothetical Updates)</h4> <p>Provenance enables <em>what-if</em> reasoning: we can ask how the output would change under
hypothetical updates, without re-running the full query or recomputing lineage.
Instead, we evaluate the existing lineage under new assumptions.</p> <p>Consider the first output row (Hannah), whose provenance polynomial is:</p> <p><code>10·c1·o1 + 100·c1·o2 + 30·c1·o4</code></p> <p>Each term combines a customer variable, an order variable, and the actual order value.
Suppose we want to recompute this total while <strong>excluding all orders that are not <code>unclassified</code></strong>.
At the polynomial level, we can model this by assigning:</p> <ul><li><code>oX = 1</code> if the order is <code>unclassified</code></li> <li><code>oX = 0</code> otherwise</li></ul> <p>In this example, orders <code>o1</code> and <code>o4</code> are unclassified, while <code>o2</code> is sensitive.
Substituting these values yields:</p> <p><code>10*1*1 + 100·*1*0 + 30*1*1 = 40</code></p> <p>The same idea can be implemented relationally using SQL.
The lineage edges identify exactly which input rows contributed to the output,
allowing us to apply the hypothetical condition at evaluation time:</p> <pre><code class="language-sql">SELECT
  SUM(
    (o.sensitivity = 'unclassified')::INT * o.value
  ) AS hypothetical_total
FROM lineage_edges AS e
JOIN orders AS o
  ON o.rowid = e.orders_iid
WHERE e.rowid = 1;
</code></pre> <p>By filtering on sensitivity during evaluation, we simulate deletions or policy changes
and immediately observe their effect on the result.</p> <h4>Use Case 3: View Maintenance</h4> <p>The same <em>what-if</em> mechanism can also be used for view maintenance.
Instead of recomputing a view from scratch when data changes,
lineage tells us exactly which outputs depend on which input tuples.</p> <p>If a base tuple is <strong>deleted</strong>, we can identify all output rows whose
polynomials reference that tuple and update only those results.
Similarly, if a tuple is <strong>updated</strong> or <strong>scaled</strong> (e.g., correcting a value or applying a multiplier),
we can re-evaluate only the affected terms in the polynomial without touching unrelated outputs.</p> <p>Lineage also works the other way: if an <strong>output row is removed or updated</strong>,
we can see which input tuples contributed to it and understand how the change propagates.</p> <p>In essence, provenance polynomials serve as a compact map of dependencies:
they show exactly how base data builds the outputs,
making incremental updates and hypothetical scenarios easy to reason about.</p> <h4>What do we get?</h4> <p>By representing lineage as an <strong>integer-based index</strong> (the lineage block),
we get several practical benefits:</p> <ul><li><strong>Compact and shareable:</strong> we can ship the lineage block to end users without sending the full data.</li> <li><strong>Efficient evaluation:</strong> if the original query is expensive, we don’t need to rerun costly joins—just join back the columns needed to answer a question.</li> <li><strong>Fast what-if analyses:</strong> we can evaluate many hypothetical updates at once. In fact, under the hood, most explanation engines rely on evaluating numerous hypothetical updates to identify the change that best explains an outlier.</li></ul> <p>These advantages make provenance not just a tool for debugging or auditing,
but a practical engine for reasoning about data, policies, and transformations.</p>`,1);function Gt(r,h){et(h,!1);let n=Ne(h,"customerTable",8),c=Ne(h,"ordersTable",8),f=Ne(h,"outputsTable",8);const v=n().map((w,g)=>{const E=g+1,S=c().map((I,N)=>({...I,rowid:N+1})).filter(I=>I.cid===w.cid);return{oid:w.cid,name:w.name,sum_value:S.reduce((I,N)=>I+N.value,0),cust_iids:[E],orders_iids:S.map(I=>I.rowid)}}),u=[];v.forEach(w=>{w.cust_iids.forEach(g=>{w.orders_iids.forEach(E=>{u.push({oid:w.oid,customer_iid:g,orders_iid:E,polynomial:`c${g}*o${E}`})})})}),rt();var i=jt(),m=l(tt(i),10),p=o(m);p.textContent=`WITH Q1_w_lineage AS (
SELECT row_number() OVER () AS rowid,
       c.name, sum(o.value),
       LIST(c.rowid) as cust_iids,
       LIST(o.rowid) as orders_iids
FROM customer c JOIN orders o USING (cid)
GROUP BY c.name
), lineage_edges AS (
SELECT rowid, UNNEST(cust_iids) customer_iid, UNNEST(orders_iids) orders_iid
FROM Q1_w_lineage
)
SELECT * FROM lineage_edges;`,e(m);var _=l(m,2),b=l(o(_));ce(b,5,()=>u,ue,(w,g)=>{var E=Bt(),S=o(E),I=o(S,!0);e(S);var N=l(S),P=o(N,!0);e(N);var O=l(N),$=o(O,!0);e(O),e(E),M(()=>{T(I,(a(g),te(()=>a(g).oid))),T(P,(a(g),te(()=>a(g).customer_iid))),T($,(a(g),te(()=>a(g).orders_iid)))}),k(w,E)}),e(b),e(_);var x=l(_,8),W=o(x);W.textContent=`SELECT
    rowid,
    STRING_AGG('c' || customer_iid || '*o' || orders_iid, ' + ') AS polynomial
FROM lineage_edges
GROUP BY rowid
`,e(x);var s=l(x,6);ce(s,5,f,ue,(w,g)=>{var E=Dt(),S=o(E),I=o(S);e(S);var N=l(S,2),P=o(N,!0);e(N),e(E),M(()=>{T(I,`${a(g),te(()=>a(g).name)??""} (oid=${a(g),te(()=>a(g).oid)??""}):`),T(P,(a(g),te(()=>a(g).polynomial)))}),k(w,E)}),e(s);var H=l(s,8),A=o(H);A.textContent=`# unclassified < sensitive < top_secret
SELECT b.rowid,
    CASE MAX(
        CASE o.sensitivity
            WHEN 'unclassified' THEN 0
            WHEN 'sensitive'    THEN 1
            WHEN 'top_secret'   THEN 2
        END
    )
    WHEN 0 THEN 'unclassified'
    WHEN 1 THEN 'sensitive'
    WHEN 2 THEN 'top_secret'
    END AS final_sensitivity
FROM lineage_edges AS b JOIN orders AS o  ON o.rowid = b.orders_iid
GROUP BY b.rowid
`,e(H),_e(42),k(r,i),at()}var Qt=C("<th>rowid</th>"),Vt=C("<th>Provenance</th>"),Yt=C("<td> </td>"),zt=C("<td><code> </code></td>"),Jt=C("<tr><!><td> </td><td> </td><td> </td><!></tr>"),Xt=C("<th>rowid</th>"),Kt=C("<th>Provenance</th>"),Zt=C("<td> </td>"),ea=C("<td><code> </code></td>"),ta=C("<tr><!><td> </td><td> </td><td> </td><td> </td><td> </td><!></tr>"),aa=C("<th>rowid</th>"),ra=C("<th>Provenance</th>"),oa=C("<td> </td>"),ia=C("<td><code> </code></td>"),na=C('<tr style="cursor:pointer;"><!><td> </td><td> </td><!></tr>'),sa=C(`<div class="sql-columns"><div class="sql-column"><h4>Customer Table</h4> <pre><code class="language-sql"> </code></pre></div> <div class="sql-column"><h4>Orders Table</h4> <pre><code class="language-sql"> </code></pre></div></div> <div class="row g-4"><div class="col-md-6"><h4>Customers</h4> <table class="table table-striped table-bordered table-sm"><thead><tr><!><th>cid</th><th>name</th><th>region</th><!></tr></thead><tbody></tbody></table></div> <div class="col-md-6"><h4>Orders</h4> <table class="table table-striped table-bordered table-sm"><thead><tr><!><th>id</th><th>cid</th><th>order_date</th><th>value</th><th>sensitivity</th><!></tr></thead><tbody></tbody></table></div></div> <div class="row g-4 mt-3"><div class="col-12">Now, let’s compute the total order value per customer with a simple SQL aggregation: <pre><code class="language-sql"></code></pre> <h4>Q1's output</h4> <table class="table table-striped table-bordered table-sm"><thead><tr><!><th>name</th><th>total_spend</th><!></tr></thead><tbody></tbody></table></div></div> <button class="btn btn-sm btn-outline-primary mb-2"> </button> <p>The tables above show how lineage works at the tuple level. 
For example, the last row in the output is produced by joining the last row in customer
with the last two rows in orders then computing the sum over them. 
By hovering over a customer or an order, you can see exactly which input rows contributed to each output.</p> <p>Hovering is just one way to visualize lineage.
At its core, lineage is a graph connecting inputs to outputs, showing exactly how each input tuple contributes to each result.
There are many ways not only to represent this graph physically, but also conceptually.</p> <!> <!>`,1);function la(r,h){et(h,!1);let n=ae(!1),c=ae(null),f=ae(null),v=ae(null),u=[{rowid:1,cid:1,name:"Hannah",region:"US"},{rowid:2,cid:2,name:"Alex",region:"EU"},{rowid:3,cid:3,name:"Maya",region:"US"}],i=[{rowid:1,id:101,cid:1,order_date:"2024-01-05",value:10,sensitivity:"unclassified"},{rowid:2,id:102,cid:1,order_date:"2024-01-12",value:100,sensitivity:"sensitive"},{rowid:3,id:103,cid:2,order_date:"2024-01-20",value:20,sensitivity:"top_secret"},{rowid:4,id:104,cid:1,order_date:"2024-02-01",value:30,sensitivity:"unclassified"},{rowid:5,id:105,cid:3,order_date:"2024-02-05",value:50,sensitivity:"unclassified"},{rowid:6,id:106,cid:3,order_date:"2024-02-10",value:70,sensitivity:"unclassified"}];u.map(t=>`(${t.cid}, '${t.name}', '${t.region}')`).join(`,
  `),i.map(t=>`(${t.id}, ${t.cid}, DATE '${t.order_date}', ${t.value}, '${t.sensitivity}')`).join(`,
  `);const m=`CREATE TABLE customer (cid INT PRIMARY KEY, name VARCHAR, region VARCHAR);
INSERT INTO customer VALUES
  ${u.map(t=>`(${t.cid}, '${t.name}', '${t.region}')`).join(`,
  `)};
`,p=`CREATE TABLE orders (id INT PRIMARY KEY, cid INT, order_date DATE, value INT, sensitivity VARCHAR);
INSERT INTO orders VALUES
  ${i.map(t=>`(${t.id}, ${t.cid}, DATE '${t.order_date}', ${t.value}, '${t.sensitivity}')`).join(`,
  `)};
`,_=u.map(t=>{const d=i.filter(F=>F.cid===t.cid),y=d.map(F=>F.id),G=d.map(F=>`${F.value}*c${t.rowid}*o${F.rowid}`).join(" + ");return{oid:t.cid,name:t.name,region:t.region,orders:y,polynomial:G}});function b(t){return!!(a(c)===t.cid||a(f)&&i.some(d=>d.id===a(f)&&d.cid===t.cid)||a(v)&&a(v).orders.some(d=>i.find(y=>y.id===d).cid===t.cid))}function x(t){return!!(a(f)===t.id||a(c)===t.cid||a(v)&&a(v).orders.includes(t.id))}function W(t){return!!(a(v)&&a(v).oid===t.oid||a(c)&&i.some(d=>t.orders.includes(d.id)&&d.cid===a(c))||a(f)&&t.orders.includes(a(f)))}rt();var s=sa(),H=tt(s),A=o(H),w=l(o(A),2),g=o(w),E=o(g,!0);e(g),e(w),e(A);var S=l(A,2),I=l(o(S),2),N=o(I),P=o(N,!0);e(N),e(I),e(S),e(H);var O=l(H,2),$=o(O),pe=l(o($),2),re=o(pe),Oe=o(re),Le=o(Oe);{var ot=t=>{var d=Qt();k(t,d)};U(Le,t=>{a(n)&&t(ot)})}var it=l(Le,4);{var nt=t=>{var d=Vt();k(t,d)};U(it,t=>{a(n)&&t(nt)})}e(Oe),e(re);var $e=l(re);ce($e,5,()=>u,ue,(t,d)=>{var y=Jt();let G;var F=o(y);{var oe=R=>{var j=Yt(),ee=o(j,!0);e(j),M(()=>T(ee,a(d).rowid)),k(R,j)};U(F,R=>{a(n)&&R(oe)})}var B=l(F),ie=o(B,!0);e(B);var D=l(B),ne=o(D,!0);e(D);var Q=l(D),se=o(Q,!0);e(Q);var L=l(Q);{var q=R=>{var j=zt(),ee=o(j),Ee=o(ee);e(ee),e(j),M(()=>T(Ee,`c${a(d).rowid??""}`)),k(R,j)};U(L,R=>{a(n)&&R(q)})}e(y),M(R=>{G=ke(y,1,"",null,G,R),T(ie,a(d).cid),T(ne,a(d).name),T(se,a(d).region)},[()=>({"table-info":b(a(d))})]),J("mouseenter",y,()=>z(c,a(d).cid)),J("mouseleave",y,()=>z(c,null)),k(t,y)}),e($e),e(pe),e($);var Fe=l($,2),qe=l(o(Fe),2),be=o(qe),Ue=o(be),Me=o(Ue);{var st=t=>{var d=Xt();k(t,d)};U(Me,t=>{a(n)&&t(st)})}var lt=l(Me,6);{var dt=t=>{var d=Kt();k(t,d)};U(lt,t=>{a(n)&&t(dt)})}e(Ue),e(be);var We=l(be);ce(We,5,()=>i,ue,(t,d)=>{var y=ta();let G;var F=o(y);{var oe=V=>{var Z=Zt(),ve=o(Z,!0);e(Z),M(()=>T(ve,a(d).rowid)),k(V,Z)};U(F,V=>{a(n)&&V(oe)})}var B=l(F),ie=o(B,!0);e(B);var D=l(B),ne=o(D,!0);e(D);var Q=l(D),se=o(Q,!0);e(Q);var L=l(Q),q=o(L,!0);e(L);var R=l(L),j=o(R,!0);e(R);var ee=l(R);{var Ee=V=>{var Z=ea(),ve=o(Z),ft=o(ve);e(ve),e(Z),M(()=>T(ft,`o${a(d).rowid??""}`)),k(V,Z)};U(ee,V=>{a(n)&&V(Ee)})}e(y),M(V=>{G=ke(y,1,"",null,G,V),T(ie,a(d).id),T(ne,a(d).cid),T(se,a(d).order_date),T(q,a(d).value),T(j,a(d).sensitivity)},[()=>({"table-warning":x(a(d))})]),J("mouseenter",y,()=>z(f,a(d).id)),J("mouseleave",y,()=>z(f,null)),k(t,y)}),e(We),e(qe),e(Fe),e(O);var we=l(O,2),Pe=o(we),ye=l(o(Pe)),ut=o(ye);ut.textContent=`Q1='SELECT c.name, SUM(o.value) AS total_spend
FROM customer c JOIN orders o USING (cid)
GROUP BY c.name'`,e(ye);var Be=l(ye,4),Te=o(Be),De=o(Te),je=o(De);{var ct=t=>{var d=aa();k(t,d)};U(je,t=>{a(n)&&t(ct)})}var pt=l(je,3);{var ht=t=>{var d=ra();k(t,d)};U(pt,t=>{a(n)&&t(ht)})}e(De),e(Te);var Ge=l(Te);ce(Ge,5,()=>_,ue,(t,d)=>{var y=na();let G;var F=o(y);{var oe=L=>{var q=oa(),R=o(q,!0);e(q),M(()=>T(R,a(d).oid)),k(L,q)};U(F,L=>{a(n)&&L(oe)})}var B=l(F),ie=o(B,!0);e(B);var D=l(B),ne=o(D,!0);e(D);var Q=l(D);{var se=L=>{var q=ia(),R=o(q),j=o(R,!0);e(R),e(q),M(()=>T(j,a(d).polynomial)),k(L,q)};U(Q,L=>{a(n)&&L(se)})}e(y),M((L,q)=>{G=ke(y,1,"",null,G,L),T(ie,a(d).name),T(ne,q)},[()=>({"table-success":W(a(d))}),()=>a(d).orders.reduce((L,q)=>L+i.find(R=>R.id===q).value,0)]),J("mouseenter",y,()=>z(v,a(d))),J("mouseleave",y,()=>z(v,null)),k(t,y)}),e(Ge),e(Be),e(Pe),e(we);var he=l(we,2),vt=o(he,!0);e(he);var Qe=l(he,6);Pt(Qe);var gt=l(Qe,2);Gt(gt,{get customerTable(){return u},get ordersTable(){return i},get outputsTable(){return _}}),M(()=>{T(E,m),T(P,p),T(vt,a(n)?"Hide metadata":"Show metadata")}),J("click",he,()=>z(n,!a(n))),k(r,s),at()}var da=C(`<div class="alert alert-secondary mt-2" style="font-size:0.9em;">Lineage and provenance can mean many things to many people.
    In general, they refer to metadata about objects and the dependencies between them.
    Objects can include datasets, models, scripts, or even humans and works of art.
    For example, family lineage models familial dependencies, while art provenance captures ownership history.
    In relational DBMSes, objects can be tables, columns, tuples, or cells.</div>`),ua=C(`<main class="container-fluid"><h1>Row-level Lineage and Its Applications</h1> <div class="row  svelte-1uha8ag"><p>In data systems, understanding how data flows through pipelines is critical.
    From ETL jobs and streaming applications to analytics dashboards, relational databases sit at the core of most data processing.
    As raw data is transformed through many stages—across queries, scripts, and workflows—the process quickly becomes complex and hard to reason about.
    When something looks wrong, it’s often hard to tell why.</p> <figure class="text-center my-4"><img alt="Lineage graph showing input-output dependencies" class="img-fluid my-3 lineage-img svelte-1uha8ag"/></figure> <p>This is where data provenance, or lineage, becomes essential <button type="button" class="sup-button svelte-1uha8ag"><sup>1</sup></button>.
    Lineage answers simple but powerful questions: Where did this data come from?
    Which inputs and scripts produced it? What would break if something changed?
    These questions are fundamental to debugging, reproducibility, and trust in data.</p> <!> <p>But, today’s lineage solutions track dependencies at the granularity of files, tables, and columns. 
      This means a user can track which files/tables/columns an output of a data program depends on.
      Its coarse grained nature (e.g. output of Q(R) depends on input relation R) limits its usage. 
      For instance, how do you trace an error in a single row of data through your data warehouse back to its source(s)?
      How do you delete all rows of data about a user throughout your data lake?
      How do you figure out why an outlying value in your chart is so high?</p> <p>Fine-grained (row) provenance, also known as row-level lineage, quickly answers these questions and more [ <a href="https://dspace.mit.edu/handle/1721.1/132280" target="_blank" class="svelte-1uha8ag">1</a>, <a href="http://www.vldb.org/pvldb/vol6/p553-wu.pdf" target="_blank" class="svelte-1uha8ag">2</a>, <a href="https://www.vldb.org/conf/2004/RS22P1.PDF" target="_blank" class="svelte-1uha8ag">3</a>, <a href="https://arxiv.org/abs/1805.02622" target="_blank" class="svelte-1uha8ag">4</a>].
      It tracks relationship between input and output of a data program at the row-level.</p> <p>This is the essence of <em>data lineage</em>. Capturing lineage enables:</p> <ul><li>Debugging: Identify the upstream rows responsible for anomalies.</li> <li>Compliance: Track sensitive or regulated data for audits.</li> <li>Optimization: Avoid unnecessary recomputation.</li> <li>“What-if” analysis: Evaluate the impact of changes in inputs.</li></ul></div> <h2 class="svelte-1uha8ag">Tracing Lineage in Action</h2> <p>Row-level lineage lets us answer questions like “Which orders contributed to this customer’s total spend?” or 
  “If I delete this row, what outputs are affected?”
  To make this concrete, we’ll use a simple dataset of customers and their orders, and show how lineage lets us trace every output back to its exact inputs.</p> <p>Let’s start with two simple tables: <code>customer</code> and <code>orders</code>.
  The customer table lists individual customers along with their region, while the orders table records each purchase, its value, and sensitivity level.</p> <!> <h2 class="mt-4 mb-3 svelte-1uha8ag">Follow-ups</h2> <ul><li><a class="link-primary svelte-1uha8ag">What-ifs? How to evaluate many provenance polynomials fast</a></li> <li><a class="link-primary svelte-1uha8ag">What-ifs: Sparse Encoding</a></li> <li><a class="link-primary svelte-1uha8ag">Lineage as a DuckDB Extension</a></li></ul></main>`);function ba(r){let h=ae(!1);var n=ua(),c=l(o(n),2),f=l(o(c),2),v=o(f);e(f);var u=l(f,2),i=l(o(u));_e(),e(u);var m=l(u,2);{var p=g=>{var E=da();k(g,E)};U(m,g=>{a(h)&&g(p)})}_e(8),e(c);var _=l(c,8);la(_,{});var b=l(_,4),x=o(b),W=o(x);e(x);var s=l(x,2),H=o(s);e(s);var A=l(s,2),w=o(A);e(A),e(b),e(n),M(()=>{fe(v,"src",`${me??""}/images/etl.jpg`),fe(W,"href",`${me??""}/part-a`),fe(H,"href",`${me??""}/part-b`),fe(w,"href",`${me??""}/part-c`)}),J("click",i,()=>z(h,!a(h))),k(r,n)}export{ba as component};
