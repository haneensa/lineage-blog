<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		
		<link href="./_app/immutable/assets/0.DBkz-poX.css" rel="stylesheet">
		<link href="./_app/immutable/assets/2.Db8jc3o4.css" rel="stylesheet">
		<link rel="modulepreload" href="./_app/immutable/entry/start.C8XR8CV1.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/DTZcO4Hy.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/DxiQdkCR.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/Eu4XPTwP.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/D-H5QWnO.js">
		<link rel="modulepreload" href="./_app/immutable/entry/app.CtoO7eRF.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/DQRcQ8WQ.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/Kp7sLg-y.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/CXLViFzr.js">
		<link rel="modulepreload" href="./_app/immutable/nodes/0.D4-bz5GD.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/CpO_WCtV.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/DvSqlD5E.js">
		<link rel="modulepreload" href="./_app/immutable/nodes/2.DYuX32hC.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/CZ1LnZdr.js">
    <title>Lineage</title>
	</head>
	<body data-sveltekit-preload-data="hover">
		<!--[--><!--[--><!----><nav class="navbar navbar-expand-lg navbar-dark bg-dark"><div class="container"><a class="navbar-brand" href=".">Lineage Blog</a> <div class="collapse navbar-collapse"><ul class="navbar-nav ms-auto"><li class="nav-item"><a class="nav-link" href=".">Main Post</a></li> <li class="nav-item"><a class="nav-link" href="./part-a">Part A</a></li> <li class="nav-item"><a class="nav-link" href="./part-b">Part B</a></li> <li class="nav-item"><a class="nav-link" href="./part-c">Part C</a></li></ul></div></div></nav> <main class="mx-5 my-5"><!--[--><!----><main class="container-fluid"><h1>Fine-grained Lineage and Its Applications</h1> <div class="row svelte-1uha8ag"><p>In modern data systems, understanding how data flows through pipelines is critical.
    From ETL jobs and streaming applications to analytics dashboards, relational databases sit at the core of most data processing.
    As raw data is transformed through many stages—across queries, scripts, and workflows—the process quickly becomes complex and hard to reason about.
    When something looks wrong, it’s often hard to tell why.</p> <figure class="text-center my-4"><img src="./images/etl.jpg" alt="Lineage graph showing input-output dependencies" class="img-fluid my-3 lineage-img svelte-1uha8ag"/></figure> <p>This is where data provenance, or lineage, becomes essential <button type="button" class="sup-button svelte-1uha8ag"><sup>1</sup></button>.
    Lineage answers simple but powerful questions: Where did this data come from?
    Which inputs and scripts produced it? What would break if something changed?
    These questions are fundamental to debugging, reproducibility, and trust in data.</p> <!--[!--><!--]--> <p>But, today’s lineage solutions track dependencies at the granularity of files and tables. 
      This means a user can track which files/tables an output of a data program depends on.
      Its coarse grained nature (e.g. output of Q(R) depends on input relation R) limits its usage. 
  For instance, how do you trace an error in a single row of data through your data warehouse back to its source(s)? How do you delete all rows of data about a user throughout your data lake? How do you figure out why an outlying value in your chart is so high?</p> <p>Fine-grained (row) provenance, also known as row-level lineage, quickly answers these questions and more [ <a href="https://dspace.mit.edu/handle/1721.1/132280" target="_blank" class="svelte-1uha8ag">2</a>, <a href="http://www.vldb.org/pvldb/vol6/p553-wu.pdf" target="_blank" class="svelte-1uha8ag">3</a>, <a href="https://www.vldb.org/conf/2004/RS22P1.PDF" target="_blank" class="svelte-1uha8ag">4</a>, <a href="https://arxiv.org/abs/1805.02622" target="_blank" class="svelte-1uha8ag">5</a>].
      It tracks relationship between input and output of a data program at the row-level.</p> <p>This is the essence of <em>data lineage</em>. Capturing lineage enables:</p> <ul><li>Debugging: Identify the upstream rows responsible for anomalies.</li> <li>Compliance: Track sensitive or regulated data for audits.</li> <li>Optimization: Avoid unnecessary recomputation.</li> <li>“What-if” analysis: Evaluate the impact of changes in inputs.</li></ul></div> <h2 class="svelte-1uha8ag">Tracing Lineage in Action</h2> <p>Fine-grained lineage lets us answer questions like “Which orders contributed to this customer’s total spend?” or 
  “If I delete this row, what outputs are affected?”
  To make this concrete, we’ll use a simple dataset of customers and their orders, and show how lineage lets us trace every output back to its exact inputs.</p> <p>Let’s start with two simple tables: customer and orders.
  The customer table lists individual customers along with their region, while the orders table records each purchase, its value, and sensitivity level.</p> <div class="sql-columns svelte-1j6s8dn"><div class="sql-column svelte-1j6s8dn"><h4>Customer Table</h4> <pre class="svelte-1j6s8dn"><code class="language-sql">CREATE TABLE customer (cid INT PRIMARY KEY, name VARCHAR, region VARCHAR);
INSERT INTO customer VALUES
  (1, 'Hannah', 'US'),
  (2, 'Alex', 'EU'),
  (3, 'Maya', 'US');
</code></pre></div> <div class="sql-column svelte-1j6s8dn"><h4>Orders Table</h4> <pre class="svelte-1j6s8dn"><code class="language-sql">CREATE TABLE orders (id INT PRIMARY KEY, cid INT, order_date DATE, value INT, sensitivity VARCHAR);
INSERT INTO orders VALUES
  (101, 1, DATE '2024-01-05', 10, 'unclassified'),
  (102, 1, DATE '2024-01-12', 100, 'sensitive'),
  (103, 2, DATE '2024-01-20', 20, 'top_secret'),
  (104, 1, DATE '2024-02-01', 30, 'unclassified'),
  (105, 3, DATE '2024-02-05', 50, 'unclassified'),
  (106, 3, DATE '2024-02-10', 70, 'unclassified');
</code></pre></div></div> <div class="row g-4"><div class="col-md-6"><h4>Customers</h4> <table class="table table-striped table-bordered table-sm"><thead><tr><!--[!--><!--]--><th>cid</th><th>name</th><th>region</th><!--[!--><!--]--></tr></thead><tbody><!--[--><tr><!--[!--><!--]--><td>1</td><td>Hannah</td><td>US</td><!--[!--><!--]--></tr><tr><!--[!--><!--]--><td>2</td><td>Alex</td><td>EU</td><!--[!--><!--]--></tr><tr><!--[!--><!--]--><td>3</td><td>Maya</td><td>US</td><!--[!--><!--]--></tr><!--]--></tbody></table></div> <div class="col-md-6"><h4>Orders</h4> <table class="table table-striped table-bordered table-sm"><thead><tr><!--[!--><!--]--><th>id</th><th>cid</th><th>order_date</th><th>value</th><th>sensitivity</th><!--[!--><!--]--></tr></thead><tbody><!--[--><tr><!--[!--><!--]--><td>101</td><td>1</td><td>2024-01-05</td><td>10</td><td>unclassified</td><!--[!--><!--]--></tr><tr><!--[!--><!--]--><td>102</td><td>1</td><td>2024-01-12</td><td>100</td><td>sensitive</td><!--[!--><!--]--></tr><tr><!--[!--><!--]--><td>103</td><td>2</td><td>2024-01-20</td><td>20</td><td>top_secret</td><!--[!--><!--]--></tr><tr><!--[!--><!--]--><td>104</td><td>1</td><td>2024-02-01</td><td>30</td><td>unclassified</td><!--[!--><!--]--></tr><tr><!--[!--><!--]--><td>105</td><td>3</td><td>2024-02-05</td><td>50</td><td>unclassified</td><!--[!--><!--]--></tr><tr><!--[!--><!--]--><td>106</td><td>3</td><td>2024-02-10</td><td>70</td><td>unclassified</td><!--[!--><!--]--></tr><!--]--></tbody></table></div></div> <div class="row g-4 mt-3"><div class="col-12">Now, let’s compute the total order value per customer with a simple SQL aggregation: <pre class="svelte-1j6s8dn"><code class="language-sql">Q1='SELECT c.name, SUM(o.value) AS total_spend
FROM customer c JOIN orders o USING (cid)
GROUP BY c.name'</code></pre> <h4>Q1's output</h4> <table class="table table-striped table-bordered table-sm"><thead><tr><!--[!--><!--]--><th>name</th><th>total_spend</th><!--[!--><!--]--></tr></thead><tbody><!--[--><tr style="cursor:pointer;"><!--[!--><!--]--><td>Hannah</td><td>140</td><!--[!--><!--]--></tr><tr style="cursor:pointer;"><!--[!--><!--]--><td>Alex</td><td>20</td><!--[!--><!--]--></tr><tr style="cursor:pointer;"><!--[!--><!--]--><td>Maya</td><td>120</td><!--[!--><!--]--></tr><!--]--></tbody></table></div></div> <button class="btn btn-sm btn-outline-primary mb-2">Show Provenance</button> <p>The tables above show how lineage works at the tuple level. 
For example, the last row in the output is linked to the last rows from orders and customer tables.
By hovering over a customer or an order, you can see exactly which input rows contributed to each output.</p> <p>Hovering is just one way to visualize lineage.
At its core, lineage is a graph connecting inputs to outputs, showing exactly how each input tuple contributes to each result.
There are many ways to represent this graph physically.</p> <h2>Representation 1: Provenance Polynomials</h2> <p>Another way to reason about the lineage graph is mathematically, using provenance polynomials.
In this abstraction, each input tuple is assigned a variable (e.g., <code>c1</code> for the first customer, <code>o1</code> for the first order), 
and relational operations combine these variables to represent how outputs are constructed:</p> <ul><li><strong>Join:</strong> multiply the variables of joined tuples</li> <li><strong>Union, projection, aggregation:</strong> add the variables of contributing tuples</li></ul> <p>For example, suppose customer <code>c1</code> is linked to orders <code>o1</code> and <code>o2</code>. 
The total spend for this customer can be represented as the polynomial: <code>c1*o1 + c1*o2</code></p> <p>This algebraic representation provides a compact, flexible summary of the same lineage graph.
For example, the lineage for each output row of Q1 can be written directly as a polynomial over input tuples:</p> <ul><!--[--><li><strong>Hannah (oid=1):</strong> <code>c1*o1 + c1*o2 + c1*o4</code></li><li><strong>Alex (oid=2):</strong> <code>c2*o3</code></li><li><strong>Maya (oid=3):</strong> <code>c3*o5 + c3*o6</code></li><!--]--></ul> <p>Each term shows a combination of customer and order rows that contributed to the output.</p> <p>These polynomials let us reason about the workflow without recomputing the full lineage.
By assigning different values to the variables and interpreting the binary operators in various ways,
we can perform a wide range of practical analyses — from computing aggregates and propagating sensitivity scores to simulating “what-if”
scenarios or tracing exactly how specific outputs were produced.</p> <ul><li><strong>Aggregates:</strong> count(), sum(), or average() over any subset of inputs</li> <li><strong>Confidentiality scoring:</strong> propagate sensitivity levels from inputs to outputs</li> <li><strong>Probabilistic reasoning:</strong> evaluate uncertainty over inputs</li> <li>View maintenance: quickly determine which outputs to keep or delete</li> <li><strong>“What-if” scenarios:</strong> simulate deletions, updates, or modifications of input rows</li></ul><!----> <h2>Representation 2: SQL and the Relational Model</h2> <p>While provenance polynomials give a compact mathematical view of lineage, we also need a way to represent and query this information in practice,
using the tools data engineers and analysts already have.</p> <p>In relational databases, we can encode the lineage graph by tracking, for each output row, which input tuples contributed to it.
The basic approach is:</p> <ul><li>Assign a unique <strong>row ID</strong> to each input tuple (for example, using the tuple's position in <code>customer</code> and <code>orders</code> tables).</li> <li>For each output row, store the <strong>list of contributing input row IDs</strong>.</li> <li>Use <code>UNNEST</code> and <code>JOIN</code> operations to generate a <strong>lineage_edges</strong> table of edges connecting inputs to outputs.</li></ul> <p>For our Q1 example, this can be expressed in SQL as:</p> <pre><code class="language-sql">WITH Q1_w_lineage AS (
SELECT row_number() OVER () AS rowid,
       c.name, sum(o.value),
       LIST(c.rowid) as cust_iids,
       LIST(o.rowid) as orders_iids
FROM customer c JOIN orders o USING (cid)
GROUP BY c.name
), lineage_edges AS (
SELECT rowid, UNNEST(cust_iids) customer_iid, UNNEST(orders_iids) orders_iid
FROM Q1_w_lineage
)
SELECT * FROM lineage_edges;</code></pre> <table class="table table-bordered table-sm"><thead><tr><th>rowid</th><th>customer_iid</th><th>orders_iid</th></tr></thead><tbody><!--[--><tr><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>2</td></tr><tr><td>1</td><td>1</td><td>4</td></tr><tr><td>2</td><td>2</td><td>3</td></tr><tr><td>3</td><td>3</td><td>5</td></tr><tr><td>3</td><td>3</td><td>6</td></tr><!--]--></tbody></table> <p>This <strong>lineage_edges</strong> represents the same information captured by the provenance polynomials,
but in a concrete relational format: each row corresponds to an <strong>edge in the lineage graph</strong>, connecting an input tuple to an output tuple.</p> <h4>Reconstructing Provenance Polynomial</h4> <p>Once we have the lineage edges connecting input tuples to outputs, we can reconstruct the provenance polynomial for each output directly in SQL. Each term in the polynomial corresponds to a pair of input tuples — for example, a customer and an order — that contributed to the output.</p> <pre><code class="language-sql">
SELECT
    rowid,
    STRING_AGG('c' || customer_iid || '*o' || orders_iid, ' + ') AS polynomial
FROM lineage_edges
GROUP BY rowid
</code></pre> <p>Each row in the <code>lineage_edges</code> table connects an input customer (<code>customer_iid</code>) to an input order (<code>orders_iid</code>) for a specific output row (<code>oid</code>). We can reconstruct the provenance polynomial for each output by combining these edges: each term <code>cX*oY</code> represents a <strong>join of a customer and an order</strong> that contributed to the output. Using <code>STRING_AGG(..., ' + ')</code>, we sum all contributing terms, reflecting the <strong>addition in provenance polynomials</strong>.</p> <p>For our Q1 example, this produces:</p> <ul><li><strong>Hannah (rowid=1):</strong> c1*o1 + c1*o2 + c1*o4</li> <li><strong>Alex (rowid=2):</strong> c2*o3</li> <li><strong>Maya (rowid=3):</strong> c3*o5 + c3*o6</li></ul> <p>This provides a <strong>concrete, queryable representation</strong> of the abstract polynomial, bridging theory and practice while keeping it fully relational.</p> <h4>Use Case 1: Evaluating Confidentialiy</h4> <p>We can also use the lineage edges to propagate metadata from inputs to outputs.
For example, consider sensitivity levels (unclassified → sensitive → top_secret) on each order. Using the lineage, we can compute the final sensitivity of each output row based on the most sensitive contributing order:</p> <pre><code class="language-sql">
# unclassified &lt; sensitive &lt; top_secret
SELECT b.rowid,
    CASE MAX(
        CASE o.sensitivity
            WHEN 'unclassified' THEN 0
            WHEN 'sensitive'    THEN 1
            WHEN 'top_secret'   THEN 2
        END
    )
    WHEN 0 THEN 'unclassified'
    WHEN 1 THEN 'sensitive'
    WHEN 2 THEN 'top_secret'
    END AS final_sensitivity
FROM lineage_edges AS b JOIN orders AS o  ON o.rowid = b.orders_iid
GROUP BY b.rowid
</code></pre> <p>This aggregates the sensitivities of all orders contributing to each output.
The MAX ensures that the output row is labeled with the most sensitive input.
This is a practical example of how provenance can be used for data governance, compliance, and risk assessment.</p> <h4>Use Case 2: What-if Analysis (Hypothetical Updates)</h4> <p>Provenance enables <em>what-if</em> reasoning: we can ask how the output would change under
hypothetical updates, without re-running the full query or recomputing lineage.
Instead, we evaluate the existing lineage under new assumptions.</p> <p>Consider the first output row (Hannah), whose provenance polynomial is:</p> <p><code>10·c1·o1 + 100·c1·o2 + 30·c1·o4</code></p> <p>Each term combines a customer variable, an order variable, and the actual order value.
Suppose we want to recompute this total while <strong>excluding all orders that are not <code>unclassified</code></strong>.
At the polynomial level, we can model this by assigning:</p> <ul><li><code>oX = 1</code> if the order is <code>unclassified</code></li> <li><code>oX = 0</code> otherwise</li></ul> <p>In this example, orders <code>o1</code> and <code>o4</code> are unclassified, while <code>o2</code> is sensitive.
Substituting these values yields:</p> <p><code>10·c1·1 + 100·c1·0 + 30·c1·1 = 40</code></p> <p>The same idea can be implemented relationally using SQL.
The lineage edges identify exactly which input rows contributed to the output,
allowing us to apply the hypothetical condition at evaluation time:</p> <pre><code class="language-sql">
SELECT
  SUM(
    (o.sensitivity = 'unclassified')::INT * o.value
  ) AS hypothetical_total
FROM lineage_edges AS e
JOIN orders AS o
  ON o.rowid = e.orders_iid
WHERE e.rowid = 1;
</code></pre> <p>By filtering on sensitivity during evaluation, we simulate deletions or policy changes
and immediately observe their effect on the result—without touching the base tables
or recomputing lineage.</p> <h4>Use Case 3: View Maintenance</h4> <p>The same <em>what-if</em> mechanism can also be used for view maintenance.
Instead of recomputing a view from scratch when data changes,
lineage tells us exactly which outputs depend on which input tuples.</p> <p>If a base tuple is <strong>deleted</strong>, we can identify all output rows whose
polynomials reference that tuple and update only those results.
Similarly, if a tuple is <strong>updated</strong> or <strong>scaled</strong> (e.g., correcting a value or applying a multiplier),
we can re-evaluate only the affected terms in the polynomial without touching unrelated outputs.</p> <p>Lineage also works the other way: if an <strong>output row is removed or updated</strong>,
we can see which input tuples contributed to it and understand how the change propagates.</p> <p>In essence, provenance polynomials serve as a compact map of dependencies:
they show exactly how base data builds the outputs,
making incremental updates and hypothetical scenarios easy to reason about.</p> <h4>What do we get?</h4> <p>By representing lineage as an <strong>integer-based index</strong> (the lineage block),
we get several practical benefits:</p> <ul><li><strong>Compact and shareable:</strong> we can ship the lineage block to end users without sending the full data.</li> <li><strong>Efficient evaluation:</strong> if the original query is expensive, we don’t need to rerun costly joins—just join back the columns needed to answer a question.</li> <li><strong>Fast what-if analyses:</strong> we can evaluate many hypothetical updates at once. In fact, under the hood, most explanation engines rely on evaluating numerous hypothetical updates to identify the change that best explains an outlier.</li></ul> <p>These advantages make provenance not just a tool for debugging or auditing,
but a practical engine for reasoning about data, policies, and transformations.</p><!----><!----> <h2 class="mt-4 mb-3 svelte-1uha8ag">Follow-ups</h2> <ul><li><a class="link-primary svelte-1uha8ag" href="./part-a">What-ifs? How to evaluate many provenance polynomials fast</a></li> <li><a class="link-primary svelte-1uha8ag" href="./part-b">What-ifs: Sparse Encoding</a></li> <li><a class="link-primary svelte-1uha8ag" href="./part-c">Lineage as a DuckDB Extension</a></li></ul></main><!----><!--]--></main><!----><!--]--> <!--[!--><!--]--><!--]-->
			
			<script>
				{
					__sveltekit_vpnye4 = {
						base: new URL(".", location).pathname.slice(0, -1),
						assets: "/lineage-blog"
					};

					const element = document.currentScript.parentElement;

					Promise.all([
						import("./_app/immutable/entry/start.C8XR8CV1.js"),
						import("./_app/immutable/entry/app.CtoO7eRF.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 2],
							data: [null,null],
							form: null,
							error: null
						});
					});
				}
			</script>
		
	</body>
</html>

