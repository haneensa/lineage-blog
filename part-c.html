<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		
		<link href="./_app/immutable/assets/0.DBkz-poX.css" rel="stylesheet">
		<link rel="modulepreload" href="./_app/immutable/entry/start.C8XR8CV1.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/DTZcO4Hy.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/DxiQdkCR.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/Eu4XPTwP.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/D-H5QWnO.js">
		<link rel="modulepreload" href="./_app/immutable/entry/app.CtoO7eRF.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/DQRcQ8WQ.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/Kp7sLg-y.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/CXLViFzr.js">
		<link rel="modulepreload" href="./_app/immutable/nodes/0.D4-bz5GD.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/CpO_WCtV.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/DvSqlD5E.js">
		<link rel="modulepreload" href="./_app/immutable/nodes/5.DdqIeaUi.js">
    <title>Lineage</title>
	</head>
	<body data-sveltekit-preload-data="hover">
		<!--[--><!--[--><!----><nav class="navbar navbar-expand-lg navbar-dark bg-dark"><div class="container"><a class="navbar-brand" href=".">Lineage Blog</a> <div class="collapse navbar-collapse"><ul class="navbar-nav ms-auto"><li class="nav-item"><a class="nav-link" href=".">Main Post</a></li> <li class="nav-item"><a class="nav-link" href="./part-a">Part A</a></li> <li class="nav-item"><a class="nav-link" href="./part-b">Part B</a></li> <li class="nav-item"><a class="nav-link" href="./part-c">Part C</a></li></ul></div></div></nav> <main class="mx-5 my-5"><!--[--><!----><main class="container-fluid"><h1>Part C: Lineage as a DuckDB Extension</h1> <p>Manually capturing lineage in SQL quickly becomes cumbersome. For example, to track which input tuples contributed to each output row for a query like Q1, you would have to write something like:</p> <pre><code class="language-sql">
WITH Q1_w_lineage AS (
    SELECT row_number() OVER () AS rowid,
           c.name, SUM(o.value),
           LIST(c.rowid) AS cust_iids,
           LIST(o.rowid) AS orders_iids
    FROM customer c
    JOIN orders o USING (cid)
    GROUP BY c.name
), lineage_edges AS (
    SELECT rowid, UNNEST(cust_iids) AS customer_iid,
                 UNNEST(orders_iids) AS orders_iid
    FROM Q1_w_lineage
)
SELECT * FROM lineage_edges;
</code></pre> <p>Even for a simple query, the rewrite involves multiple steps: assigning output row IDs, collecting input row lists, and unnesting them into edges.
As queries get more complex—with joins, aggregations, or nested subqueries—this approach quickly becomes error-prone and hard to maintain.</p> <p>The <strong>DuckDB lineage extension</strong> solves this problem by automatically capturing fine-grained lineage at the logical plan level.
It adds annotation columns to track input-to-output dependencies, persists them in memory, and still returns the original query results.</p> <p>Users can enable lineage capture with a single command:</p> <pre><code class="language-sql">
LOAD 'lineage.duckdb_extension';
PRAGMA set_lineage(True);

-- execute any query as usual
SELECT c.name, SUM(o.value) AS total_spend
FROM customer c
JOIN orders o USING (cid)
GROUP BY c.name;

PRAGMA set_lineage(False);
</code></pre> <p>Once the query finishes, lineage edges are available through a simple table function:</p> <pre><code class="language-sql">
SELECT *
FROM read_block(
    (SELECT max(query_id) FROM pragma_latest_qid())
);
</code></pre> <h4>Downloading and Using the Extension</h4> <p>The DuckDB lineage extension is not yet officially verified, but you can download it directly from GitHub artifacts using the provided script:</p> <pre><code class="language-bash">
# download lineage.duckdb_extension from GitHub artifacts
python3 https://github.com/haneensa/lineage/blob/main/scripts/download_extension.py
</code></pre> <p>To use the extension in DuckDB, make sure to allow unsigned extensions when connecting:</p> <pre><code class="language-python">
import duckdb

# Allow unsigned extensions when connecting
con = duckdb.connect(config={  'allow_unsigned_extensions': True  })

# Load the lineage extension
con.execute("LOAD 'lineage';")

# Enable lineage capture
con.execute("PRAGMA set_lineage(True)")

# Execute any query as usual
con.execute("""
    SELECT c.name, SUM(o.value) AS total_spend
    FROM customer c
    JOIN orders o USING (cid)
    GROUP BY c.name
""")

# Disable lineage capture
con.execute("PRAGMA set_lineage(False)")

lineage_edges = con.execute(f"SELECT *
FROM read_block(
    (SELECT max(query_id) FROM pragma_latest_qid())
);").fetchdf()
</code></pre> <p>This setup allows you to capture full fine-grained lineage without rewriting queries or modifying your workflow.</p> <h2 class="mt-4 mb-3">Follow-ups</h2> <ul><li><a class="link-primary" href="./part-a">What-ifs? How to evaluate many provenance polynomials fast</a></li> <li><a class="link-primary" href="./part-b">What-ifs: Sparse Encoding</a></li> <li><a class="link-primary" href=".">← Back to main post</a></li></ul></main><!----><!--]--></main><!----><!--]--> <!--[!--><!--]--><!--]-->
			
			<script>
				{
					__sveltekit_vpnye4 = {
						base: new URL(".", location).pathname.slice(0, -1),
						assets: "/lineage-blog"
					};

					const element = document.currentScript.parentElement;

					Promise.all([
						import("./_app/immutable/entry/start.C8XR8CV1.js"),
						import("./_app/immutable/entry/app.CtoO7eRF.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 5],
							data: [null,null],
							form: null,
							error: null
						});
					});
				}
			</script>
		
	</body>
</html>

